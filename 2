use std::collections::hash_map::HashMap;
use std::sync::mpsc;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

pub enum Msg {
    Data { producer: i32, value: i32 } ,
    Done { producer: i32 },
}

#[derive(Debug)]
pub struct Data {
    sum: i32,
    closed: bool,
}

fn main() {
    let _ = run_system(3, 1, 5, false);
}

fn run_system(
    producers: i32,
    consumers: i32,
    msgs_per_producer: i32,
    inject_early_done: bool,
) -> HashMap<i32, Data> {
    let (tx, rx) = mpsc::channel();
    let shared_map: Arc<Mutex<HashMap<i32, Data>>> = Arc::new(Mutex::new(HashMap::new()));

    let mut handles = Vec::new();
    for i in 0..producers {
        let mut map = shared_map.lock().unwrap();
        map.insert(
            i,
            Data {
                sum: 0,
                closed: false,
            },
        );
    }

    for i in 0..producers {
        
    }

    drop(tx);

    // Consumer
    for _ in 0..consumers {
        for value in rx {
            match value {
                Msg::Data(x, y) => {
                    println!("received {y} from producer {x}");
                    let mut data_map = shared_map.lock().unwrap();
                    let prod_data = data_map.get_mut(&x);
                    match prod_data {
                        Some(m) => {
                            if m.closed {
                                println!("producer {x} alread closed");
                                continue;
                            }
                            m.sum += y;
                        }
                        None => println!("producer {x} not found"),
                    }
                }
                Msg::Done(x) => {
                    println!("producer {x} finished");
                    let mut data_map = shared_map.lock().unwrap();
                    let prod_data = data_map.get_mut(&x);
                    match prod_data {
                        Some(m) => {
                            if m.closed {
                                println!("producer {x} already closed");
                                continue;
                            }
                            println!("producer {x} sent sum {}", m.sum);
                            m.closed = true;
                        }
                        None => println!("producer {x} not found"),
                    }
                }
            }
        }
    }

    for h in handles {
        h.join().unwrap();
    }

    println!("all done");
    let final_map = Arc::try_unwrap(shared_map).unwrap().into_inner().unwrap();
    return final_map;
}

fn spawn_producer(id: i32, msgs_per_producer: i32, inject_early_done: bool, tx: mpsc::Sender<Msg>) -> thread::JoinHandle<()> {
    thread::spawn(move || {
        for n in 0..msgs_per_producer {
            // injecting some funny business
            if inject_early_done && n == 3 {
                tx.send(Msg::Done { producer: id }).unwrap();
            }
            let k = id * 10 + n;
            tx.send(Msg::Data { producer: id, value: k }).unwrap();
            println!("Sent {k}");
        }
        tx.send(Msg::Done { producer: id }).unwrap();
    }) 
}

pub fn process_msg(msg: Msg, state: &mut HashMap<i32, Data>) {
}


#[cfg(test)]
mod tests {
    use super::*;

    fn expected_sum(producer: i32, count: usize) -> i32 {
        (0..count).map(|n| producer * 10 + n as i32).sum()
    }

    fn assert_completes_within<F>(timeout: Duration, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let (tx, rx) = mpsc::channel();

        thread::spawn(move || {
            f();
            let _ = tx.send(());
        });

        match rx.recv_timeout(timeout) {
            Ok(_) => {} // success
            Err(mpsc::RecvTimeoutError::Timeout) => {
                panic!("operation timed out after {:?}", timeout);
            }
            Err(e) => panic!("unexpected error: {:?}", e),
        }
    }

    #[test]
    fn normal_execution_all_data_counted() {
        let result = run_system(
            3,     // producers
            2,     // consumers
            5,     // messages per producer
            false, // no early Done
        );

        for p in 0..3 {
            let data = result.get(&p).expect("missing producer");
            assert!(data.closed, "producer {p} not closed");
            assert_eq!(
                data.sum,
                expected_sum(p, 5),
                "incorrect sum for producer {p}"
            );
        }
    }

    #[test]
    fn no_double_done_corruption() {
        let result = run_system(3, 2, 5, true);

        for (_, data) in result {
            assert!(data.sum >= 0);
        }
    }

    // -------------------------

    #[test]
    fn single_consumer_all_data_counted() {
        let result = run_system(3, 1, 5, false);

        for p in 0..3 {
            let data = result.get(&p).unwrap();
            assert!(data.closed);
            assert_eq!(data.sum, expected_sum(p, 5));
        }
    }

    #[test]
    fn multiple_consumers_same_result() {
        let result = run_system(3, 4, 5, false);

        for p in 0..3 {
            let data = result.get(&p).unwrap();
            assert!(data.closed);
            assert_eq!(data.sum, expected_sum(p, 5));
        }
    }

    #[test]
    fn early_done_ignores_late_data() {
        let result = run_system(3, 3, 5, true);

        for p in 0..3 {
            let data = result.get(&p).unwrap();
            assert!(data.closed);
            assert_eq!(data.sum, expected_sum(p, 3));
        }
    }

    #[test]
    fn no_double_counting_with_many_consumers() {
        let result = run_system(5, 8, 100, false);

        for p in 0..5 {
            let data = result.get(&p).unwrap();
            assert_eq!(data.sum, expected_sum(p, 100));
        }
    }

    #[test]
    fn system_terminates_cleanly() {
        assert_completes_within(
            Duration::from_secs(2), 
            || {
                let _ = run_system(5, 5, 10, false);
            },
        );
    }
}
